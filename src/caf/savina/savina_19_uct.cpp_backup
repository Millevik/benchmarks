/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Dominik Charousset <dominik.charousset (at) haw-hamburg.de>                *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENCE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

#include "caf/all.hpp"

using namespace std;
using std::chrono::seconds;
using namespace caf;

#define CAF_ALLOW_UNSAFE_MESSAGE_TYPE(type_name)                               \
  namespace caf {                                                              \
  template <>                                                                  \
  struct allowed_unsafe_message_type<type_name> : std::true_type {};           \
  }


class config : public actor_system_config {
public:
  int max_nodes = 200000;
  int avg_comp_size = 500; // average computation size
  int stdev_comp_size = 100; // standard deviation of the compuation size
  // binomial parameer: each node may have either 0 or binomianl children
  int binomial_param = 500; 
  int urgent_node_percent = 50; // percentage of urgent nodes
  static bool debug; // = false;

  config() {
    opt_group{custom_options_, "global"}
      .add(max_nodes, "nnn,n", "maximum nodes")
      .add(avg_comp_size, "aaa,a", "average computation size")
      .add(stdev_comp_size, "sss,s",
           "standard deviation of the compuation size")
      .add(binomial_param, "bbb,b", "binominal parameter")
      .add(debug, "ddd,d", "debug");
  }
};
bool config::debug = false;

//int loop(int busywait, int dummy) {
  //int test = 0;
  //for (int k = 0; k < dummy * busywait; k++) {
    //test++;
  //}
  //return test;
//}

//using get_id_msg_atom = atom_constant<atom("getid")>;
//using print_info_msg_atom = atom_constant<atom("printinfo")>;
//using generate_tree_msg_atom = atom_constant<atom("gentree")>;
//using try_generate_tree_msg_atom = atom_constant<atom("trygen")>;

//struct generate_children_msg {
  //int current_id;
  //int comp_size;
//};
//CAF_ALLOW_UNSAFE_MESSAGE_TYPE(generate_children_msg);

//struct urgent_generate_children_msg {
  //int urgent_child_id;
  //int current_id;
  //int comp_size;
//};
//CAF_ALLOW_UNSAFE_MESSAGE_TYPE(urgent_generate_children_msg);

//using traverse_msg_atom = atom_constant<atom("travserse")>;
//using urgent_traverse_msg_atom = atom_constant<atom("utraverse")>;

//struct should_generate_children_msg {
  //actor sender;
  //int child_height;
//};
//CAF_ALLOW_UNSAFE_MESSAGE_TYPE(should_generate_children_msg);

//struct update_grant_msg {
  //int child_id; 
//};
//CAF_ALLOW_UNSAFE_MESSAGE_TYPE(update_grant_msg);

//using terminate_msg_atom = atom_constant<atom("terminate")>;

//behavior root_actor_fun(event_based_actor* self) {
  //return {
  
  //};
//}

//behavior node_actor_fun(event_based_actor* self, actor my_parent, actor my_root, int my_height, int my_id, int my_comp_size, bool is_urgent) {
  //return {
  
  //};  
//}


void caf_main(actor_system& system, const config& cfg) {
  //auto root_actor = system.spawn(root_actor_fun);
  //anon_send(root_actor, generate_tree_msg_atom::value);
}

CAF_MAIN()
